"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventEmitter = require('./events');
var CachePool = require('./cache');
var Backend = require('./backend');

/**
 * @typedef {Object} StreamFileOptions
 * @property {string} url - the URL to fetch
 * @property {number} chunkSize - max size of each chunked HTTP request / readahead target
 * @property {number} cacheSize - max amount of data to keep buffered in memory for seeks
 */

/**
 * Utility class for chunked streaming of large files via XMLHttpRequest.
 * Provides an abstraction of a seekable input stream, backed by in-memory
 * caching, and some convenient promise-based i/o methods.
 * @param {StreamFileOptions} options
 * @constructor
 */

var StreamFile = function () {
  function StreamFile(_ref) {
    var _ref$url = _ref.url;
    var url = _ref$url === undefined ? '' : _ref$url;
    var _ref$chunkSize = _ref.chunkSize;
    var chunkSize = _ref$chunkSize === undefined ? 1 * 1024 * 1024 : _ref$chunkSize;
    var _ref$cacheSize = _ref.cacheSize;
    var cacheSize = _ref$cacheSize === undefined ? 0 : _ref$cacheSize;
    var _ref$progressive = _ref.progressive;
    var progressive = _ref$progressive === undefined ? true : _ref$progressive;

    _classCallCheck(this, StreamFile);

    // InputStream public API
    this.length = -1;
    this.loaded = false;
    this.loading = false;
    this.seekable = false;
    this.buffering = false;
    this.seeking = false;
    this.progressive = progressive;

    Object.defineProperties(this, {
      /**
       * Byte offset of the read head
       */
      offset: {
        get: function get() {
          return this._cache.readOffset;
        }
      },

      /**
       * Is the read head at the end of the file?
       */
      eof: {
        get: function get() {
          return this.length === this._cache.readOffset;
        }
      }
    });

    // StreamFile public API
    this.url = url;
    this.headers = {};

    // Private
    this._cache = new CachePool({
      cacheSize: cacheSize
    });

    this._backend = null;
    this._cachever = 0;
    this._chunkSize = chunkSize;
  }

  /**
   * Open the file, get metadata, and start buffering some data.
   * On success, loaded will become true, headers may be filled out,
   * and length may be available.
   *
   * @returns {Promise}
   */


  _createClass(StreamFile, [{
    key: 'load',
    value: function load() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (_this.loading) {
          throw new Error('cannot load when loading');
        }
        if (_this.loaded) {
          throw new Error('cannot load when loaded');
        }
        _this.loading = true;
        _this._openBackend().then(function (backend) {
          // Save metadata from the first set...
          // Beware this._backend may be null already,
          // if the first segment was very short!
          _this.seekable = backend.seekable;
          _this.headers = backend.headers;
          _this.length = backend.length;
          _this.loaded = true;
          _this.loading = false;
          resolve();
        }).catch(function (err) {
          if (err.name !== 'AbortError') {
            _this.loading = false;
          }
          reject(err);
        });
      });
    }

    /**
     * Create a backend and wait for it to load.
     * The returned 'backend' object may be null if there is no data to read.
     *
     * @returns {Promise}
     */

  }, {
    key: '_openBackend',
    value: function _openBackend() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (_this2._backend) {
          resolve(_this2._backend);
        } else if (_this2.eof) {
          reject(new Error('cannot open at end of file'));
        } else {
          var cache = _this2._cache;
          var max = _this2._chunkSize;

          // Seek forward to the next unread point, up to chunk size
          var readable = cache.bytesReadable(max);
          var readTail = cache.readOffset + readable;
          cache.seekWrite(readTail);

          // Did we already cache the entire file?
          if (_this2.length >= 0 && readTail >= _this2.length) {
            resolve(null);
            return;
          }

          // Do we have space to write within that chunk?
          // Don't go beyond the end of the file, or it will confuse
          // some browsers (Safari with blob URLs).
          var writable = _this2._clampToLength(cache.writeOffset + cache.bytesWritable(max)) - cache.writeOffset;

          if (writable === 0) {
            // Nothing to read/write within the current readahead area.
            resolve(null);
          } else {
            (function () {
              var backend = _this2._backend = new Backend({
                url: _this2.url,
                offset: _this2._cache.writeOffset,
                length: writable,
                cachever: _this2._cachever,
                progressive: _this2.progressive
              });

              var oncomplete = null;

              var checkOpen = function checkOpen() {
                if (backend !== _this2._backend) {
                  oncomplete();
                  reject(new Error('invalid state'));
                } else {
                  backend.on('buffer', function (buffer) {
                    if (backend === _this2._backend) {
                      _this2._cache.write(buffer);
                    }
                  });
                  backend.on('done', function () {
                    if (backend === _this2._backend) {
                      if (_this2.length === -1) {
                        // save length on those final thingies
                        _this2.length = _this2._backend.offset + _this2._backend.bytesRead;
                      }
                      _this2._backend = null;
                    }
                  });
                  resolve(backend);
                }
              };

              var checkError = function checkError(err) {
                if (backend !== _this2._backend) {
                  reject(new Error('invalid state'));
                } else {
                  _this2._backend = null;
                  reject(err);
                }
              };

              oncomplete = function oncomplete() {
                backend.off('open', checkOpen);
                backend.off('error', checkError);
              };
              backend.on('open', checkOpen);
              backend.on('error', checkError);
              backend.on('cachever', function () {
                _this2._cachever++;
              });

              backend.load();
            })();
          }
        }
      });
    }

    /**
     * If we have empty space within the readahead area and there is not already
     * a download backend in place, create one and start it loading in background.
     * @returns {Promise}
     */

  }, {
    key: '_readAhead',
    value: function _readAhead() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3._backend || _this3.eof) {
          // do nothing
          resolve();
        } else {
          _this3._openBackend().then(function () {
            resolve();
          }).catch(function (err) {
            reject(err);
          });
        }
      });
    }

    /**
     * Seek the read position to a new location in the file, asynchronously.
     * After succesful completion, reads will continue at the new offset.
     * May fail due to network problems, invalid input, or bad state.
     * @param {number} offset - target byte offset from beginning of file
     * @returns {Promise} - resolved when ready to read at the new position
     */

  }, {
    key: 'seek',
    value: function seek(offset) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (!_this4.loaded || _this4.buffering || _this4.seeking) {
          throw new Error('invalid state');
        } else if (offset !== (offset | 0) || offset < 0) {
          throw new Error('invalid input');
        } else if (_this4.length >= 0 && offset > _this4.length) {
          throw new Error('seek past end of file');
        } else if (!_this4.seekable) {
          throw new Error('seek on non-seekable stream');
        } else {
          if (_this4._backend) {
            // @todo if a short seek forward, just keep reading?
            _this4.abort();
          }
          _this4._cache.seekRead(offset);
          _this4._cache.seekWrite(offset);

          // Fire off a download if necessary.
          _this4._readAhead().then(resolve).catch(reject);
        }
      });
    }

    /**
     * Read up to the requested number of bytes, or until end of file is reached,
     * and advance the read head.
     *
     * May wait on network activity if data is not yet available.
     *
     * @param {number} nbytes - max number of bytes to read
     * @returns {ArrayBuffer} - between 0 and nbytes of data, inclusive
     */

  }, {
    key: 'read',
    value: function read(nbytes) {
      var _this5 = this;

      return this.buffer(nbytes).then(function (available) {
        return _this5.readSync(available);
      });
    }

    /**
     * Read up to the requested number of bytes, or however much is available
     * in the buffer until the next empty segment, and advance the read head.
     *
     * Returns immediately.
     *
     * @param {number} nbytes - max number of bytes to read
     * @returns {ArrayBuffer} - between 0 and nbytes of data, inclusive
     */

  }, {
    key: 'readSync',
    value: function readSync(nbytes) {
      var available = this.bytesAvailable(nbytes);
      var dest = new Uint8Array(available);
      var actual = this.readBytes(dest);
      if (actual !== available) {
        throw new Error('failed to read expected data');
      }
      return dest.buffer;
    }

    /**
     * Read bytes into destination array until out of buffer or space,
     * and advance the read head.
     *
     * Returns immediately.
     *
     * @param {dest} Uint8Array - destination byte array
     * @returns {number} - count of actual bytes read
     */

  }, {
    key: 'readBytes',
    value: function readBytes(dest) {
      if (!this.loaded || this.buffering || this.seeking) {
        throw new Error('invalid state');
      } else if (!(dest instanceof Uint8Array)) {
        throw new Error('invalid input');
      }
      var nbytes = this._cache.readBytes(dest);

      // Trigger readahead if necessary.
      this._readAhead();

      return nbytes;
    }

    /**
     * Wait until the given number of bytes are available to read, or end of file.
     * @param {number} nbytes - max bytes to wait for
     * @returns {Promise} - resolved with available byte count when ready
     */

  }, {
    key: 'buffer',
    value: function buffer(nbytes) {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        if (!_this6.loaded || _this6.buffering || _this6.seeking) {
          throw new Error('invalid state');
        } else if (nbytes !== (nbytes | 0) || nbytes < 0) {
          throw new Error('invalid input');
        }
        var end = _this6._clampToLength(_this6.offset + nbytes);
        var readable = end - _this6.offset;

        var canceled = false;

        var available = _this6.bytesAvailable(readable);
        if (available >= readable) {
          // Requested data is immediately available.
          resolve(available);
        } else {
          _this6.buffering = true;

          // If we don't already have a backend open, start downloading.
          _this6._openBackend().then(function (backend) {
            if (backend) {
              return backend.bufferToOffset(end).then(function () {
                // We might have to roll over to another download,
                // so loop back around!
                _this6.buffering = false;
                return _this6.buffer(nbytes);
              });
            } else {
              // No more data to read.
              return Promise.resolve(available);
            }
          }).then(function (available) {
            _this6.buffering = false;
            resolve(available);
          }).catch(function (err) {
            if (err.name !== 'AbortError') {
              // was already set synchronously; avoid stomping on old promise
              _this6.buffering = false;
            }
            reject(err);
          });
        }
      });
    }

    /**
     * Number of bytes available to read immediately from the current offset.
     * This is the max number of bytes that can be returned from a read() call.
     * @returns {boolean}
     */

  }, {
    key: 'bytesAvailable',
    value: function bytesAvailable() {
      var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;

      return this._cache.bytesReadable(max);
    }

    /**
     * Abort any currently running downloads and operations.
     */

  }, {
    key: 'abort',
    value: function abort() {
      // Clear state synchronously, so can immediately launch new i/o...
      if (this.loading) {
        this.loading = false;
      }
      if (this.buffering) {
        this.buffering = false;
      }
      if (this.seeking) {
        this.seeking = false;
      }

      // Abort any active backend request...
      if (this._backend) {
        this._backend.abort();
        this._backend = null;
      }
    }

    /**
     * Return an array of byte ranges that are buffered.
     * Each range is a two-element array of start and end.
     * @returns {Array<Array<number>>}
     */

  }, {
    key: 'getBufferedRanges',
    value: function getBufferedRanges() {
      return this._cache.ranges();
    }

    // ------
    // private methods
    // ------

  }, {
    key: '_clampToLength',
    value: function _clampToLength(offset) {
      if (this.length < 0) {
        return offset;
      } else {
        return Math.min(this.length, offset);
      }
    }
  }]);

  return StreamFile;
}();

module.exports = StreamFile;
