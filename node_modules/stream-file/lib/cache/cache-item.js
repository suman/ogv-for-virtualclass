"use strict";

/**
 * Double-linked list cache items
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CacheItem = function () {
  function CacheItem() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref$buffer = _ref.buffer;
    var buffer = _ref$buffer === undefined ? undefined : _ref$buffer;
    var _ref$string = _ref.string;
    var string = _ref$string === undefined ? undefined : _ref$string;
    var _ref$start = _ref.start;
    var start = _ref$start === undefined ? 0 : _ref$start;
    var _ref$end = _ref.end;
    var end = _ref$end === undefined ? start + (buffer ? buffer.byteLength : string ? string.length : 0) : _ref$end;
    var _ref$prev = _ref.prev;
    var prev = _ref$prev === undefined ? null : _ref$prev;
    var _ref$next = _ref.next;
    var next = _ref$next === undefined ? null : _ref$next;
    var _ref$eof = _ref.eof;
    var eof = _ref$eof === undefined ? false : _ref$eof;
    var _ref$empty = _ref.empty;
    var empty = _ref$empty === undefined ? !(buffer || string) : _ref$empty;
    var _ref$timestamp = _ref.timestamp;
    var timestamp = _ref$timestamp === undefined ? Date.now() : _ref$timestamp;

    _classCallCheck(this, CacheItem);

    this.start = start;
    this.end = end;
    this.prev = prev;
    this.next = next;
    this.eof = eof;
    this.empty = empty;
    this.timestamp = timestamp;
    this.buffer = buffer;
    this.string = string;
    Object.defineProperty(this, 'length', {
      get: function get() {
        return this.end - this.start;
      }
    });
  }

  /**
   * True if this cache item contains the given byte offset.
   * False if outside.
   */


  _createClass(CacheItem, [{
    key: 'contains',
    value: function contains(offset) {
      return offset >= this.start && (offset < this.end || this.eof);
    }
  }, {
    key: 'readBytes',
    value: function readBytes(dest, start, end) {
      var readHead = start - this.start;
      var len = end - start;
      if (this.buffer) {
        var sourceBytes = new Uint8Array(this.buffer, readHead, len);
        dest.set(sourceBytes);
      } else if (this.string) {
        var chunk = this.string;
        for (var i = 0; i < len; i++) {
          dest[i] = chunk.charCodeAt(readHead + i);
        }
      } else {
        throw new Error('invalid state');
      }
      this.timestamp = Date.now();
    }
  }, {
    key: 'split',
    value: function split(offset) {
      if (!this.empty || !this.contains(offset)) {
        throw new Error('invalid split');
      }
      var a = new CacheItem({
        start: this.start,
        end: offset
      });
      var b = new CacheItem({
        start: offset,
        end: this.eof ? offset : this.end,
        eof: this.eof
      });
      a.next = b;
      b.prev = a;
      return [a, b];
    }

    /**
     * Iterate forwards, returning the first element matching the callback.
     * @param {function} callback - return true for a match on item
     * @returns {CacheItem|null} - matching item or null if none found
     */

  }, {
    key: 'first',
    value: function first(callback) {
      for (var item = this; item; item = item.next) {
        if (callback(item)) {
          return item;
        }
      }
      return null;
    }

    /**
     * Iterate forwards, returning the last element matching the callback before
     * reaching one that doesn't match or we find the end.
     * @param {function} callback - return true for a match on item
     * @returns {CacheItem|null} - matching item or null if none found
     */

  }, {
    key: 'last',
    value: function last(callback) {
      var last = null;
      for (var item = this; item; item = item.next) {
        if (!callback(item)) {
          break;
        }
        last = item;
      }
      return last;
    }
  }]);

  return CacheItem;
}();

module.exports = CacheItem;
