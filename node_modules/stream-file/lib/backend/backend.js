"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TinyEvents = require('../events');

/**
 * Extract the file's total length from the XHR returned headers.
 * @returns {number} - byte length or -1
 * @access private
 */
function getXHRLength(xhr) {
  if (xhr.status == 206) {
    return getXHRRangeTotal(xhr);
  } else {
    var contentLength = xhr.getResponseHeader('Content-Length');
    if (contentLength === null || contentLength === '') {
      // Unknown file length... maybe streaming live?
      return -1;
    } else {
      return parseInt(contentLength, 10);
    }
  }
}

/**
 * Extract the range chunk info from the XHR returned headers.
 * @returns {Array} - byte length or -1
 * @access private
 */
function getXHRRangeMatches(xhr) {
  // Note Content-Range must be whitelisted for CORS requests
  var contentRange = xhr.getResponseHeader('Content-Range');
  return contentRange && contentRange.match(/^bytes (\d+)-(\d+)\/(\d+)/);
}

/**
 * Extract the chunk start position from the XHR returned headers.
 * @returns {number} - byte position or 0
 * @access private
 */
function getXHRRangeStart(xhr) {
  var matches = getXHRRangeMatches(xhr);
  if (matches) {
    return parseInt(matches[1], 10);
  } else {
    return 0;
  }
}

/**
 * Extract the file's total length from the XHR returned headers.
 * @returns {number} - byte length or -1
 * @access private
 */
function getXHRRangeTotal(xhr) {
  var matches = getXHRRangeMatches(xhr);
  if (matches) {
    return parseInt(matches[3], 10);
  } else {
    return -1;
  }
}

/**
 * Record the HTTP headers from the initial request, in case some are useful.
 * @returns {Object} map of headers
 * @access private
 */
function getXHRHeaders(xhr) {
  var headers = {};
  var headerLines = xhr.getAllResponseHeaders().split(/\r?\n/);
  headerLines.forEach(function (line) {
    var bits = line.split(/:\s*/, 2);
    if (bits.length > 1) {
      headers[bits[0].toLowerCase()] = bits[1];
    }
  });
  return headers;
}

/**
 * Represents a single HTTP request pass through part of a URL.
 *
 * Subclasses handle details of chunking/strings/streams and provide
 * a unified internal API.
 *
 * Events sent:
 * - 'open' - called when file metadata ready
 * - 'buffer' - passes a BufferSegment in with some new data
 * - 'done' - called at end of file
 * - 'error' - called in case of error
 * - 'cachever' - triggered when old Safari caching bug found
 */

var Backend = function (_TinyEvents) {
  _inherits(Backend, _TinyEvents);

  function Backend(_ref) {
    var url = _ref.url;
    var offset = _ref.offset;
    var length = _ref.length;
    var _ref$cachever = _ref.cachever;
    var cachever = _ref$cachever === undefined ? 0 : _ref$cachever;

    _classCallCheck(this, Backend);

    var _this = _possibleConstructorReturn(this, (Backend.__proto__ || Object.getPrototypeOf(Backend)).call(this));

    _this.url = url;
    _this.offset = offset;
    _this.length = length;
    _this.cachever = cachever;

    _this.loaded = false;
    _this.seekable = false;
    _this.headers = {};
    _this.eof = false;
    _this.bytesRead = 0;
    _this.xhr = new XMLHttpRequest();
    return _this;
  }

  _createClass(Backend, [{
    key: 'load',
    value: function load() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var oncomplete = null;
        _this2._onAbort = function (err) {
          oncomplete();
          reject(err);
        };
        var checkOpen = function checkOpen() {
          // There doesn't seem to be a good match for readyState 2 on the XHR2 events model.
          if (_this2.xhr.readyState == 2) {
            if (_this2.xhr.status == 206) {
              // Partial content -- we are streamable
              var foundPosition = getXHRRangeStart(_this2.xhr);
              if (_this2.offset != foundPosition) {
                //
                // Safari sometimes messes up and gives us the wrong chunk.
                // Seems to be a general problem with Safari and cached XHR ranges.
                //
                // Interestingly, it allows you to request _later_ ranges successfully,
                // but when requesting _earlier_ ranges it returns the latest one retrieved.
                // So we only need to update the cache-buster when we rewind and actually
                // get an incorrect range.
                //
                // https://bugs.webkit.org/show_bug.cgi?id=82672
                //
                console.log('Expected start at ' + _this2.offset + ' but got ' + foundPosition + '; working around Safari range caching bug: https://bugs.webkit.org/show_bug.cgi?id=82672');
                _this2.cachever++;
                _this2.emit('cachever');
                _this2.abort();
                oncomplete();
                _this2.load().then(resolve).catch(reject);
                return;
              }
              _this2.seekable = true;
            }
            if (_this2.xhr.status >= 200 && _this2.xhr.status < 300) {
              _this2.length = getXHRLength(_this2.xhr);
              _this2.headers = getXHRHeaders(_this2.xhr);
              _this2.onXHRStart();
            } else {
              oncomplete();
              reject(new Error('HTTP error ' + _this2.xhr.status));
            }
          }
        };
        var checkError = function checkError() {
          oncomplete();
          reject(new Error('network error'));
        };
        var checkBackendOpen = function checkBackendOpen() {
          oncomplete();
          resolve();
        };
        oncomplete = function oncomplete() {
          _this2.xhr.removeEventListener('readystatechange', checkOpen);
          _this2.xhr.removeEventListener('error', checkError);
          _this2.off('open', checkBackendOpen);
          _this2._onAbort = null;
        };

        _this2.initXHR();

        // Events for the open promise
        _this2.xhr.addEventListener('readystatechange', checkOpen);
        _this2.xhr.addEventListener('error', checkError);
        _this2.on('open', checkBackendOpen);

        _this2.xhr.send();
      });
    }

    /**
     * Wait until we download up to the given offset, reach eof, or error out.
     * Actual data will be returned via 'buffer' events in the meantime.
     *
     * Note that MSStream backend will need this to be called explicitly,
     * while the other backends download progressively even without a call.
     */

  }, {
    key: 'bufferToOffset',
    value: function bufferToOffset(end) {
      return Promise.reject(new Error('abstract'));
    }
  }, {
    key: 'abort',
    value: function abort() {
      this.xhr.abort();

      if (this._onAbort) {
        var onAbort = this._onAbort;
        this._onAbort = null;

        var err = new Error('Aborted');
        err.name = 'AbortError';

        onAbort(err);
      }
    }

    // ---------------
    // Private methods
    // ---------------

  }, {
    key: 'initXHR',
    value: function initXHR() {
      var getUrl = this.url;
      if (this.cachever) {
        //
        // Safari sometimes messes up and gives us the wrong chunk.
        // Seems to be a general problem with Safari and cached XHR ranges.
        //
        // Interestingly, it allows you to request _later_ ranges successfully,
        // but when requesting _earlier_ ranges it returns the latest one retrieved.
        // So we only need to update the cache-buster when we rewind.
        //
        // https://bugs.webkit.org/show_bug.cgi?id=82672
        //
        getUrl += '?buggy_cachever=' + this.cachever;
      }

      this.xhr.open("GET", getUrl);

      var range = null;
      if (this.offset || this.length) {
        range = 'bytes=' + this.offset + '-';
      }
      if (this.length) {
        range += this.offset + this.length - 1;
      }
      if (range !== null) {
        this.xhr.setRequestHeader('Range', range);
      }
    }
  }, {
    key: 'onXHRStart',
    value: function onXHRStart() {
      throw new Error('abstract');
    }
  }]);

  return Backend;
}(TinyEvents);

module.exports = Backend;
