(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.StreamFile = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DownloadBackend = _dereq_('./download-backend.js');

var type = 'arraybuffer';

var ArrayBufferBackend = function (_DownloadBackend) {
  _inherits(ArrayBufferBackend, _DownloadBackend);

  function ArrayBufferBackend() {
    _classCallCheck(this, ArrayBufferBackend);

    return _possibleConstructorReturn(this, (ArrayBufferBackend.__proto__ || Object.getPrototypeOf(ArrayBufferBackend)).apply(this, arguments));
  }

  _createClass(ArrayBufferBackend, [{
    key: 'initXHR',
    value: function initXHR() {
      _get(ArrayBufferBackend.prototype.__proto__ || Object.getPrototypeOf(ArrayBufferBackend.prototype), 'initXHR', this).call(this);
      this.xhr.responseType = type;
    }
  }, {
    key: 'onXHRProgress',
    value: function onXHRProgress() {
      // no progressive download available. wait until the end.
    }
  }, {
    key: 'onXHRLoad',
    value: function onXHRLoad() {
      var buf = this.xhr.response;
      this.bytesRead += buf.byteLength;
      this.emit('buffer', buf);

      _get(ArrayBufferBackend.prototype.__proto__ || Object.getPrototypeOf(ArrayBufferBackend.prototype), 'onXHRLoad', this).call(this);
    }
  }]);

  return ArrayBufferBackend;
}(DownloadBackend);

ArrayBufferBackend.supported = function () {
  try {
    var xhr = new XMLHttpRequest();
    xhr.responseType = type;
    return xhr.responseType === type;
  } catch (e) {
    return false;
  }
};

module.exports = ArrayBufferBackend;

},{"./download-backend.js":4}],2:[function(_dereq_,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TinyEvents = _dereq_('../events');

/**
 * Extract the file's total length from the XHR returned headers.
 * @returns {number} - byte length or -1
 * @access private
 */
function getXHRLength(xhr) {
  if (xhr.status == 206) {
    return getXHRRangeTotal(xhr);
  } else {
    var contentLength = xhr.getResponseHeader('Content-Length');
    if (contentLength === null || contentLength === '') {
      // Unknown file length... maybe streaming live?
      return -1;
    } else {
      return parseInt(contentLength, 10);
    }
  }
}

/**
 * Extract the range chunk info from the XHR returned headers.
 * @returns {Array} - byte length or -1
 * @access private
 */
function getXHRRangeMatches(xhr) {
  // Note Content-Range must be whitelisted for CORS requests
  var contentRange = xhr.getResponseHeader('Content-Range');
  return contentRange && contentRange.match(/^bytes (\d+)-(\d+)\/(\d+)/);
}

/**
 * Extract the chunk start position from the XHR returned headers.
 * @returns {number} - byte position or 0
 * @access private
 */
function getXHRRangeStart(xhr) {
  var matches = getXHRRangeMatches(xhr);
  if (matches) {
    return parseInt(matches[1], 10);
  } else {
    return 0;
  }
}

/**
 * Extract the file's total length from the XHR returned headers.
 * @returns {number} - byte length or -1
 * @access private
 */
function getXHRRangeTotal(xhr) {
  var matches = getXHRRangeMatches(xhr);
  if (matches) {
    return parseInt(matches[3], 10);
  } else {
    return -1;
  }
}

/**
 * Record the HTTP headers from the initial request, in case some are useful.
 * @returns {Object} map of headers
 * @access private
 */
function getXHRHeaders(xhr) {
  var headers = {};
  var headerLines = xhr.getAllResponseHeaders().split(/\r?\n/);
  headerLines.forEach(function (line) {
    var bits = line.split(/:\s*/, 2);
    if (bits.length > 1) {
      headers[bits[0].toLowerCase()] = bits[1];
    }
  });
  return headers;
}

/**
 * Represents a single HTTP request pass through part of a URL.
 *
 * Subclasses handle details of chunking/strings/streams and provide
 * a unified internal API.
 *
 * Events sent:
 * - 'open' - called when file metadata ready
 * - 'buffer' - passes a BufferSegment in with some new data
 * - 'done' - called at end of file
 * - 'error' - called in case of error
 * - 'cachever' - triggered when old Safari caching bug found
 */

var Backend = function (_TinyEvents) {
  _inherits(Backend, _TinyEvents);

  function Backend(_ref) {
    var url = _ref.url;
    var offset = _ref.offset;
    var length = _ref.length;
    var _ref$cachever = _ref.cachever;
    var cachever = _ref$cachever === undefined ? 0 : _ref$cachever;

    _classCallCheck(this, Backend);

    var _this = _possibleConstructorReturn(this, (Backend.__proto__ || Object.getPrototypeOf(Backend)).call(this));

    _this.url = url;
    _this.offset = offset;
    _this.length = length;
    _this.cachever = cachever;

    _this.loaded = false;
    _this.seekable = false;
    _this.headers = {};
    _this.eof = false;
    _this.bytesRead = 0;
    _this.xhr = new XMLHttpRequest();
    return _this;
  }

  _createClass(Backend, [{
    key: 'load',
    value: function load() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var oncomplete = null;
        _this2._onAbort = function (err) {
          oncomplete();
          reject(err);
        };
        var checkOpen = function checkOpen() {
          // There doesn't seem to be a good match for readyState 2 on the XHR2 events model.
          if (_this2.xhr.readyState == 2) {
            if (_this2.xhr.status == 206) {
              // Partial content -- we are streamable
              var foundPosition = getXHRRangeStart(_this2.xhr);
              if (_this2.offset != foundPosition) {
                //
                // Safari sometimes messes up and gives us the wrong chunk.
                // Seems to be a general problem with Safari and cached XHR ranges.
                //
                // Interestingly, it allows you to request _later_ ranges successfully,
                // but when requesting _earlier_ ranges it returns the latest one retrieved.
                // So we only need to update the cache-buster when we rewind and actually
                // get an incorrect range.
                //
                // https://bugs.webkit.org/show_bug.cgi?id=82672
                //
                console.log('Expected start at ' + _this2.offset + ' but got ' + foundPosition + '; working around Safari range caching bug: https://bugs.webkit.org/show_bug.cgi?id=82672');
                _this2.cachever++;
                _this2.emit('cachever');
                _this2.abort();
                oncomplete();
                _this2.load().then(resolve).catch(reject);
                return;
              }
              _this2.seekable = true;
            }
            if (_this2.xhr.status >= 200 && _this2.xhr.status < 300) {
              _this2.length = getXHRLength(_this2.xhr);
              _this2.headers = getXHRHeaders(_this2.xhr);
              _this2.onXHRStart();
            } else {
              oncomplete();
              reject(new Error('HTTP error ' + _this2.xhr.status));
            }
          }
        };
        var checkError = function checkError() {
          oncomplete();
          reject(new Error('network error'));
        };
        var checkBackendOpen = function checkBackendOpen() {
          oncomplete();
          resolve();
        };
        oncomplete = function oncomplete() {
          _this2.xhr.removeEventListener('readystatechange', checkOpen);
          _this2.xhr.removeEventListener('error', checkError);
          _this2.off('open', checkBackendOpen);
          _this2._onAbort = null;
        };

        _this2.initXHR();

        // Events for the open promise
        _this2.xhr.addEventListener('readystatechange', checkOpen);
        _this2.xhr.addEventListener('error', checkError);
        _this2.on('open', checkBackendOpen);

        _this2.xhr.send();
      });
    }

    /**
     * Wait until we download up to the given offset, reach eof, or error out.
     * Actual data will be returned via 'buffer' events in the meantime.
     *
     * Note that MSStream backend will need this to be called explicitly,
     * while the other backends download progressively even without a call.
     */

  }, {
    key: 'bufferToOffset',
    value: function bufferToOffset(end) {
      return Promise.reject(new Error('abstract'));
    }
  }, {
    key: 'abort',
    value: function abort() {
      this.xhr.abort();

      if (this._onAbort) {
        var onAbort = this._onAbort;
        this._onAbort = null;

        var err = new Error('Aborted');
        err.name = 'AbortError';

        onAbort(err);
      }
    }

    // ---------------
    // Private methods
    // ---------------

  }, {
    key: 'initXHR',
    value: function initXHR() {
      var getUrl = this.url;
      if (this.cachever) {
        //
        // Safari sometimes messes up and gives us the wrong chunk.
        // Seems to be a general problem with Safari and cached XHR ranges.
        //
        // Interestingly, it allows you to request _later_ ranges successfully,
        // but when requesting _earlier_ ranges it returns the latest one retrieved.
        // So we only need to update the cache-buster when we rewind.
        //
        // https://bugs.webkit.org/show_bug.cgi?id=82672
        //
        getUrl += '?buggy_cachever=' + this.cachever;
      }

      this.xhr.open("GET", getUrl);

      var range = null;
      if (this.offset || this.length) {
        range = 'bytes=' + this.offset + '-';
      }
      if (this.length) {
        range += this.offset + this.length - 1;
      }
      if (range !== null) {
        this.xhr.setRequestHeader('Range', range);
      }
    }
  }, {
    key: 'onXHRStart',
    value: function onXHRStart() {
      throw new Error('abstract');
    }
  }]);

  return Backend;
}(TinyEvents);

module.exports = Backend;

},{"../events":11}],3:[function(_dereq_,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DownloadBackend = _dereq_('./download-backend.js');

var BinaryStringBackend = function (_DownloadBackend) {
  _inherits(BinaryStringBackend, _DownloadBackend);

  function BinaryStringBackend() {
    _classCallCheck(this, BinaryStringBackend);

    return _possibleConstructorReturn(this, (BinaryStringBackend.__proto__ || Object.getPrototypeOf(BinaryStringBackend)).apply(this, arguments));
  }

  _createClass(BinaryStringBackend, [{
    key: "initXHR",
    value: function initXHR() {
      _get(BinaryStringBackend.prototype.__proto__ || Object.getPrototypeOf(BinaryStringBackend.prototype), "initXHR", this).call(this);
      this.xhr.responseType = "text";
      this.xhr.overrideMimeType('text/plain; charset=x-user-defined');
    }
  }, {
    key: "onXHRProgress",
    value: function onXHRProgress() {
      var slice = this.xhr.responseText.slice(this.bytesRead);
      if (slice.length > 0) {
        this.bytesRead += slice.length;
        this.emit('buffer', slice);
      }
    }
  }, {
    key: "onXHRLoad",
    value: function onXHRLoad() {
      // We may or may not get that final event
      this.onXHRProgress();
      _get(BinaryStringBackend.prototype.__proto__ || Object.getPrototypeOf(BinaryStringBackend.prototype), "onXHRLoad", this).call(this);
    }
  }]);

  return BinaryStringBackend;
}(DownloadBackend);

BinaryStringBackend.supported = function () {
  try {
    var xhr = new XMLHttpRequest();
    return !!xhr.overrideMimeType;
  } catch (e) {
    return false;
  }
};

module.exports = BinaryStringBackend;

},{"./download-backend.js":4}],4:[function(_dereq_,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Backend = _dereq_('./backend.js');

/**
 * Backend for progressive downloading.
 * Subclasses handle details of strings/buffers.
 */

var DownloadBackend = function (_Backend) {
  _inherits(DownloadBackend, _Backend);

  function DownloadBackend() {
    _classCallCheck(this, DownloadBackend);

    return _possibleConstructorReturn(this, (DownloadBackend.__proto__ || Object.getPrototypeOf(DownloadBackend)).apply(this, arguments));
  }

  _createClass(DownloadBackend, [{
    key: 'bufferToOffset',
    value: function bufferToOffset(end) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (_this2.eof || _this2.offset >= end) {
          resolve();
        } else {
          (function () {
            var oncomplete = null;
            _this2._onAbort = function (err) {
              oncomplete();
              reject(err);
            };

            var checkBuffer = function checkBuffer() {
              if (_this2.offset >= end && !_this2.eof) {
                oncomplete();
                resolve();
              }
            };
            var checkDone = function checkDone() {
              oncomplete();
              resolve();
            };
            var checkError = function checkError() {
              oncomplete();
              reject(new Error('error streaming'));
            };

            oncomplete = function oncomplete() {
              _this2.buffering = false;
              _this2.off('buffer', checkBuffer);
              _this2.off('done', checkDone);
              _this2.off('error', checkError);
              _this2._onAbort = null;
            };

            _this2.buffering = true;
            _this2.on('buffer', checkBuffer);
            _this2.on('done', checkDone);
            _this2.on('error', checkError);
          })();
        }
      });
    }
  }, {
    key: 'initXHR',
    value: function initXHR() {
      _get(DownloadBackend.prototype.__proto__ || Object.getPrototypeOf(DownloadBackend.prototype), 'initXHR', this).call(this);
    }
  }, {
    key: 'onXHRStart',
    value: function onXHRStart() {
      var _this3 = this;

      // Event handlers to drive output
      this.xhr.addEventListener('progress', function () {
        return _this3.onXHRProgress();
      });
      this.xhr.addEventListener('error', function () {
        return _this3.onXHRError();
      });
      this.xhr.addEventListener('load', function () {
        return _this3.onXHRLoad();
      });

      this.emit('open');
    }
  }, {
    key: 'onXHRProgress',
    value: function onXHRProgress() {
      throw new Error('abstract');
    }
  }, {
    key: 'onXHRError',
    value: function onXHRError() {
      this.emit('error');
    }
  }, {
    key: 'onXHRLoad',
    value: function onXHRLoad() {
      this.eof = true;
      this.emit('done');
    }
  }]);

  return DownloadBackend;
}(Backend);

module.exports = DownloadBackend;

},{"./backend.js":2}],5:[function(_dereq_,module,exports){
"use strict";

var MozChunkedBackend = _dereq_('./moz-chunked-backend.js');
var MSStreamBackend = _dereq_('./msstream-backend.js');
var BinaryStringBackend = _dereq_('./binary-string-backend.js');
var ArrayBufferBackend = _dereq_('./arraybuffer-backend.js');

function autoselect() {
  // Only include progressive-capable for now
  if (MozChunkedBackend.supported()) {
    return MozChunkedBackend;
  } else if (BinaryStringBackend.supported()) {
    return BinaryStringBackend;
  } else if (MSStreamBackend.supported()) {
    return MSStreamBackend;
  } else {
    return null;
  }
}

var backendClass = null;

function instantiate(options) {
  if (options.progressive === false) {
    return new ArrayBufferBackend(options);
  }
  if (!backendClass) {
    backendClass = autoselect();
  }
  if (!backendClass) {
    throw new Error('No supported backend class');
  }
  return new backendClass(options);
}

module.exports = instantiate;

},{"./arraybuffer-backend.js":1,"./binary-string-backend.js":3,"./moz-chunked-backend.js":6,"./msstream-backend.js":7}],6:[function(_dereq_,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DownloadBackend = _dereq_('./download-backend.js');

var type = 'moz-chunked-arraybuffer';

var MozChunkedBackend = function (_DownloadBackend) {
  _inherits(MozChunkedBackend, _DownloadBackend);

  function MozChunkedBackend() {
    _classCallCheck(this, MozChunkedBackend);

    return _possibleConstructorReturn(this, (MozChunkedBackend.__proto__ || Object.getPrototypeOf(MozChunkedBackend)).apply(this, arguments));
  }

  _createClass(MozChunkedBackend, [{
    key: 'initXHR',
    value: function initXHR() {
      _get(MozChunkedBackend.prototype.__proto__ || Object.getPrototypeOf(MozChunkedBackend.prototype), 'initXHR', this).call(this);
      this.xhr.responseType = type;
    }
  }, {
    key: 'onXHRProgress',
    value: function onXHRProgress() {
      var buffer = this.xhr.response;
      this.bytesRead += buffer.byteLength;
      this.emit('buffer', buffer);
    }
  }]);

  return MozChunkedBackend;
}(DownloadBackend);

MozChunkedBackend.supported = function () {
  try {
    var xhr = new XMLHttpRequest();
    xhr.responseType = type;
    return xhr.responseType === type;
  } catch (e) {
    return false;
  }
};

module.exports = MozChunkedBackend;

},{"./download-backend.js":4}],7:[function(_dereq_,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Backend = _dereq_('./backend.js');

var type = 'ms-stream';

var MSStreamBackend = function (_Backend) {
  _inherits(MSStreamBackend, _Backend);

  function MSStreamBackend(options) {
    _classCallCheck(this, MSStreamBackend);

    var _this = _possibleConstructorReturn(this, (MSStreamBackend.__proto__ || Object.getPrototypeOf(MSStreamBackend)).call(this, options));

    _this.stream = null;
    _this.streamReader = null;
    return _this;
  }

  _createClass(MSStreamBackend, [{
    key: 'initXHR',
    value: function initXHR() {
      _get(MSStreamBackend.prototype.__proto__ || Object.getPrototypeOf(MSStreamBackend.prototype), 'initXHR', this).call(this);
      this.xhr.responseType = type;
    }
  }, {
    key: 'onXHRStart',
    value: function onXHRStart() {
      var _this2 = this;

      var checkProgress = function checkProgress() {
        if (_this2.xhr.readyState === 3) {
          // We don't get the stream until readyState 3, and it's gone after load.
          _this2.stream = _this2.xhr.response;
          _this2.xhr.removeEventListener('readystatechange', checkProgress);
          _this2.emit('open');
        }
      };
      this.xhr.addEventListener('readystatechange', checkProgress);
    }
  }, {
    key: 'waitForStream',
    value: function waitForStream() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.stream) {
          resolve(_this3.stream);
        } else {
          (function () {
            var oncomplete = null;
            _this3._onAbort = function (err) {
              oncomplete();
              reject(err);
            };
            var checkStart = function checkStart() {
              resolve(_this3.stream);
            };
            oncomplete = function oncomplete() {
              _this3.off('open', checkStart);
              _this3._onAbort = null;
            };
            _this3.on('open', checkStart);
          })();
        }
      });
    }

    /**
     * Trigger further download of bytes
     * @returns {Promise}
     */

  }, {
    key: 'bufferToOffset',
    value: function bufferToOffset(end) {
      var _this4 = this;

      return this.waitForStream().then(function (stream) {
        return new Promise(function (resolve, reject) {
          if (_this4.streamReader) {
            throw new Error('cannot trigger read when reading');
          }
          if (_this4.offset >= end || _this4.eof) {
            resolve();
          } else {
            var nbytes = end - _this4.offset;
            _this4.streamReader = new MSStreamReader();
            _this4.streamReader.onload = function (event) {
              _this4.streamReader = null;
              var buffer = event.target.result;
              if (buffer.byteLength > 0) {
                _this4.bytesRead += buffer.byteLength;
                _this4.emit('buffer', buffer);
              } else {
                // Zero length means end of stream.
                _this4.eof = true;
                _this4.emit('done');
              }
              resolve();
            };
            _this4.streamReader.onerror = function () {
              _this4.streamReader = null;
              _this4.stream = null;
              _this4.emit('error');
              reject(new Error('mystery error streaming'));
            };
            _this4._onAbort = function (err) {
              _this4.streamReader.abort();
              _this4.streamReader = null;
              _this4.stream = null;
              _this4.emit('error');
              reject(err);
            };
            _this4.streamReader.readAsArrayBuffer(stream, nbytes);
          }
        });
      });
    }
  }, {
    key: 'abort',
    value: function abort() {
      if (this.streamReader) {
        this.streamReader.abort();
        this.streamReader = null;
      }
      if (this.stream) {
        this.stream.msClose();
        this.stream = null;
      }
      _get(MSStreamBackend.prototype.__proto__ || Object.getPrototypeOf(MSStreamBackend.prototype), 'abort', this).call(this);
    }
  }]);

  return MSStreamBackend;
}(Backend);

MSStreamBackend.supported = function () {
  try {
    var xhr = new XMLHttpRequest();
    // IE demands that open() be called before we can set xhr.responseType
    xhr.open("GET", "/robots.txt");
    xhr.responseType = type;
    return xhr.responseType === type;
  } catch (e) {
    return false;
  }
};

module.exports = MSStreamBackend;

},{"./backend.js":2}],8:[function(_dereq_,module,exports){
"use strict";

/**
 * Double-linked list cache items
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CacheItem = function () {
  function CacheItem() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref$buffer = _ref.buffer;
    var buffer = _ref$buffer === undefined ? undefined : _ref$buffer;
    var _ref$string = _ref.string;
    var string = _ref$string === undefined ? undefined : _ref$string;
    var _ref$start = _ref.start;
    var start = _ref$start === undefined ? 0 : _ref$start;
    var _ref$end = _ref.end;
    var end = _ref$end === undefined ? start + (buffer ? buffer.byteLength : string ? string.length : 0) : _ref$end;
    var _ref$prev = _ref.prev;
    var prev = _ref$prev === undefined ? null : _ref$prev;
    var _ref$next = _ref.next;
    var next = _ref$next === undefined ? null : _ref$next;
    var _ref$eof = _ref.eof;
    var eof = _ref$eof === undefined ? false : _ref$eof;
    var _ref$empty = _ref.empty;
    var empty = _ref$empty === undefined ? !(buffer || string) : _ref$empty;
    var _ref$timestamp = _ref.timestamp;
    var timestamp = _ref$timestamp === undefined ? Date.now() : _ref$timestamp;

    _classCallCheck(this, CacheItem);

    this.start = start;
    this.end = end;
    this.prev = prev;
    this.next = next;
    this.eof = eof;
    this.empty = empty;
    this.timestamp = timestamp;
    this.buffer = buffer;
    this.string = string;
    Object.defineProperty(this, 'length', {
      get: function get() {
        return this.end - this.start;
      }
    });
  }

  /**
   * True if this cache item contains the given byte offset.
   * False if outside.
   */


  _createClass(CacheItem, [{
    key: 'contains',
    value: function contains(offset) {
      return offset >= this.start && (offset < this.end || this.eof);
    }
  }, {
    key: 'readBytes',
    value: function readBytes(dest, start, end) {
      var readHead = start - this.start;
      var len = end - start;
      if (this.buffer) {
        var sourceBytes = new Uint8Array(this.buffer, readHead, len);
        dest.set(sourceBytes);
      } else if (this.string) {
        var chunk = this.string;
        for (var i = 0; i < len; i++) {
          dest[i] = chunk.charCodeAt(readHead + i);
        }
      } else {
        throw new Error('invalid state');
      }
      this.timestamp = Date.now();
    }
  }, {
    key: 'split',
    value: function split(offset) {
      if (!this.empty || !this.contains(offset)) {
        throw new Error('invalid split');
      }
      var a = new CacheItem({
        start: this.start,
        end: offset
      });
      var b = new CacheItem({
        start: offset,
        end: this.eof ? offset : this.end,
        eof: this.eof
      });
      a.next = b;
      b.prev = a;
      return [a, b];
    }

    /**
     * Iterate forwards, returning the first element matching the callback.
     * @param {function} callback - return true for a match on item
     * @returns {CacheItem|null} - matching item or null if none found
     */

  }, {
    key: 'first',
    value: function first(callback) {
      for (var item = this; item; item = item.next) {
        if (callback(item)) {
          return item;
        }
      }
      return null;
    }

    /**
     * Iterate forwards, returning the last element matching the callback before
     * reaching one that doesn't match or we find the end.
     * @param {function} callback - return true for a match on item
     * @returns {CacheItem|null} - matching item or null if none found
     */

  }, {
    key: 'last',
    value: function last(callback) {
      var last = null;
      for (var item = this; item; item = item.next) {
        if (!callback(item)) {
          break;
        }
        last = item;
      }
      return last;
    }
  }]);

  return CacheItem;
}();

module.exports = CacheItem;

},{}],9:[function(_dereq_,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CacheItem = _dereq_('./cache-item.js');

/**
 * Seekable, readable, writable buffer cache to represent a file.
 * @todo add max cache size and LRU cache expiration
 *
 * Internally, will always contain entries from 0 to some given out point.
 * Each item may either contain data, or be empty.
 * Empty ranges cannot be copied out via read(), non-empty ranges can.
 * Empty ranges can be filled up with write(), non-empty ranges cannot.
 *
 * Internal invariants:
 * - head and tail are always present, may be same for empty
 * - tail item is always empty/eof
 * - non-empty items are never 0 bytes
 * - adjacent list items are always continguous
 * - empty items are never adjacent to each other
 */

var CachePool = function () {
  function CachePool() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref$cacheSize = _ref.cacheSize;
    var cacheSize = _ref$cacheSize === undefined ? 0 : _ref$cacheSize;

    _classCallCheck(this, CachePool);

    var eof = new CacheItem({ eof: true });
    this.head = eof;
    this.tail = eof;
    this.readOffset = 0;
    this.readCursor = eof;
    this.writeOffset = 0;
    this.writeCursor = eof;
    this.cacheSize = cacheSize;
  }

  /**
   * Is the read cursor at the end of the file?
   */


  _createClass(CachePool, [{
    key: 'bytesReadable',


    /**
     * Count how many bytes are available from the given offset.
     * @param {number} max - optional maximum to read
     * @returns {number} 0 or more
     */
    value: function bytesReadable() {
      var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;

      var offset = this.readOffset;
      var cursor = this.readCursor;
      var last = cursor.last(function (item) {
        return !item.empty && item.start <= offset + max;
      });
      if (last) {
        return Math.min(max, last.end - offset);
      }
      return 0;
    }

    /**
     * Count how many bytes are available to write.
     * @param {number} max - optional maximum to write
     * @returns {number} 0 or more, or +Infinity
     */

  }, {
    key: 'bytesWritable',
    value: function bytesWritable() {
      var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;

      var offset = this.writeOffset;
      var cursor = this.writeCursor;
      if (cursor.eof) {
        return max;
      }
      var last = cursor.last(function (item) {
        return item.empty && item.start <= offset + max;
      });
      if (last) {
        return Math.min(max, last.end - offset);
      }
      return 0;
    }

    /**
     * Move the read head to a given offset. The read head can move beyond the
     * currently known end of the file, but cannot move before 0.
     * @param {number} offset - bytes from beginning of virtual file to read from
     */

  }, {
    key: 'seekRead',
    value: function seekRead(offset) {
      var target = this.head.first(function (item) {
        return item.contains(offset);
      });
      if (!target) {
        throw new Error('read seek out of range');
      }
      this.readOffset = offset;
      this.readCursor = target;
    }

    /**
     * Move the write head to a given offset. The write head can move beyond the
     * currently known end of the file, but cannot move before 0.
     * @param {number} offset - bytes from beginning of virtual file to write to
     */

  }, {
    key: 'seekWrite',
    value: function seekWrite(offset) {
      var target = this.head.first(function (item) {
        return item.contains(offset);
      });
      if (!target) {
        throw new Error('write seek out of range');
      }
      this.writeOffset = offset;
      this.writeCursor = target;
    }

    /**
     * Read up to the requested number of bytes, or however much is available
     * in the buffer until the next empty segment, and advance the read head.
     *
     * Returns immediately.
     *
     * @param {Uint8Array} dest - destination array to read to
     * @returns {number} - count of bytes actually read
     */

  }, {
    key: 'readBytes',
    value: function readBytes(dest) {
      var nbytes = dest.byteLength;
      var len = this.bytesReadable(nbytes);
      var start = this.readOffset;
      var end = start + len;

      var readHead = start;
      var writeHead = 0;
      for (var item = this.readCursor; item; item = item.next) {
        if (item.empty) {
          break;
        }
        if (item.start >= end) {
          break;
        }
        var readTail = Math.min(end, item.end);
        var chunk = dest.subarray(readHead - start, readTail - start);
        item.readBytes(chunk, readHead, readTail);
        readHead = readTail;
      }
      this.readOffset = readHead;
      this.readCursor = this.readCursor.first(function (item) {
        return item.contains(readHead);
      });

      return len;
    }

    /**
     * Write a data buffer at the write head and advance the write head.
     * The data must fit in the available empty space in the buffer cache.
     * @param {ArrayBuffer|String} buffer
     */

  }, {
    key: 'write',
    value: function write(buffer) {
      var item = this.bufferItem(buffer);
      var cursor = this.writeCursor;

      if (!cursor.empty) {
        throw new Error('write cursor not empty');
      }
      if (!cursor.contains(item.end) && cursor.end !== item.end) {
        throw new Error('write cursor too small');
      }

      if (cursor.start < item.start) {
        this.split(cursor, item.start);
        cursor = this.writeCursor;
      }

      if (item.end < cursor.end || cursor.eof) {
        this.split(cursor, item.end);
        cursor = this.writeCursor;
      }

      this.splice(cursor, cursor, item, item);
      this.writeOffset = item.end;
      this.writeCursor = item.next;

      this.gc();
    }
  }, {
    key: 'bufferItem',
    value: function bufferItem(buffer) {
      if (buffer instanceof ArrayBuffer) {
        return new CacheItem({
          start: this.writeOffset,
          end: this.writeOffset + buffer.byteLength,
          buffer: buffer
        });
      } else if (typeof buffer === 'string') {
        return new CacheItem({
          start: this.writeOffset,
          end: this.writeOffset + buffer.length,
          string: buffer
        });
      } else {
        throw new Error('invalid input to write');
      }
    }
  }, {
    key: 'split',
    value: function split(oldItem, offset) {
      var items = oldItem.split(offset);
      this.splice(oldItem, oldItem, items[0], items[1]);
    }

    /**
     * Return an array of arrays of consolidated cached ranges
     */

  }, {
    key: 'ranges',
    value: function ranges() {
      var ranges = [];

      for (var item = this.head; item; item = item.next) {
        if (item.empty) {
          continue;
        }
        var start = item;
        item = item.last(function (i) {
          return !i.empty;
        });
        ranges.push([start.start, item.end]);
      }

      return ranges;
    }
  }, {
    key: 'gc',
    value: function gc() {
      // Simple gc: look at anything not between read head and write head,
      // and discard the oldest items until we have room
      var cachedBytes = 0;
      var candidates = [];
      for (var item = this.head; item; item = item.next) {
        if (!item.empty) {
          cachedBytes += item.length;
          if (item.end < this.readOffset || item.start > this.readOffset + this.chunkSize) {
            // Not in the 'hot' readahead range
            candidates.push(item);
          }
        }
      }
      if (cachedBytes > this.cacheSize) {
        candidates.sort(function (a, b) {
          return a.timestamp - b.timestamp;
        });

        for (var i = 0; i < candidates.length; i++) {
          var _item = candidates[i];
          if (cachedBytes <= this.cacheSize) {
            break;
          }
          this.remove(_item);
          cachedBytes -= _item.length;
        }
      }
    }
  }, {
    key: 'remove',
    value: function remove(item) {
      var replacement = new CacheItem({
        start: item.start,
        end: item.end
      });
      this.splice(item, item, replacement, replacement);
      item = replacement;

      // Consolidate adjacent ranges
      if (item.prev && item.prev.empty) {
        item = this.consolidate(item.prev);
      }
      if (item.next && item.next.empty && !item.next.eof) {
        item = this.consolidate(item);
      }
      if (item.start === 0) {
        this.head = item;
      }
    }
  }, {
    key: 'consolidate',
    value: function consolidate(first) {
      var last = first.last(function (item) {
        return item.empty && !item.eof;
      });
      var replacement = new CacheItem({
        start: first.start,
        end: last.end
      });
      this.splice(first, last, replacement, replacement);
      return replacement;
    }
  }, {
    key: 'splice',
    value: function splice(oldHead, oldTail, newHead, newTail) {
      var _this = this;

      if (oldHead.start !== newHead.start) {
        throw new Error('invalid splice head');
      }
      if (oldTail.end !== newTail.end) {
        if (oldTail.eof && newTail.eof) {
          // only eof is expandable
        } else {
          throw new Error('invalid splice tail');
        }
      }
      var prev = oldHead.prev;
      var next = oldTail.next;

      oldHead.prev = null;
      oldTail.next = null;

      if (prev) {
        prev.next = newHead;
        newHead.prev = prev;
      }
      if (next) {
        next.prev = newTail;
        newTail.next = next;
      }

      if (oldHead === this.head) {
        this.head = newHead;
      }
      if (oldTail === this.tail) {
        this.tail = newTail;
      }
      this.readCursor = this.head.first(function (item) {
        return item.contains(_this.readOffset);
      });
      this.writeCursor = this.head.first(function (item) {
        return item.contains(_this.writeOffset);
      });
    }
  }, {
    key: 'eof',
    get: function get() {
      return this.readCursor.eof;
    }
  }]);

  return CachePool;
}();

module.exports = CachePool;

},{"./cache-item.js":8}],10:[function(_dereq_,module,exports){
"use strict";

module.exports = _dereq_('./cache-pool.js');

},{"./cache-pool.js":9}],11:[function(_dereq_,module,exports){
"use strict";

// just the bits we need

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TinyEvents = function () {
  function TinyEvents() {
    _classCallCheck(this, TinyEvents);

    this._e = {};
  }

  _createClass(TinyEvents, [{
    key: "on",
    value: function on(name, handler) {
      (this._e[name] || (this._e[name] = [])).push(handler);
    }
  }, {
    key: "off",
    value: function off(name, handler) {
      var l = this._e[name] || [];
      var i = l.indexOf(handler);
      if (handler >= 0) {
        l.splice(i, 1);
      }
    }
  }, {
    key: "emit",
    value: function emit(name, arg) {
      (this._e[name] || []).slice().forEach(function (f) {
        return f(arg);
      });
    }
  }]);

  return TinyEvents;
}();

module.exports = TinyEvents;

},{}],12:[function(_dereq_,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventEmitter = _dereq_('./events');
var CachePool = _dereq_('./cache');
var Backend = _dereq_('./backend');

/**
 * @typedef {Object} StreamFileOptions
 * @property {string} url - the URL to fetch
 * @property {number} chunkSize - max size of each chunked HTTP request / readahead target
 * @property {number} cacheSize - max amount of data to keep buffered in memory for seeks
 */

/**
 * Utility class for chunked streaming of large files via XMLHttpRequest.
 * Provides an abstraction of a seekable input stream, backed by in-memory
 * caching, and some convenient promise-based i/o methods.
 * @param {StreamFileOptions} options
 * @constructor
 */

var StreamFile = function () {
  function StreamFile(_ref) {
    var _ref$url = _ref.url;
    var url = _ref$url === undefined ? '' : _ref$url;
    var _ref$chunkSize = _ref.chunkSize;
    var chunkSize = _ref$chunkSize === undefined ? 1 * 1024 * 1024 : _ref$chunkSize;
    var _ref$cacheSize = _ref.cacheSize;
    var cacheSize = _ref$cacheSize === undefined ? 0 : _ref$cacheSize;
    var _ref$progressive = _ref.progressive;
    var progressive = _ref$progressive === undefined ? true : _ref$progressive;

    _classCallCheck(this, StreamFile);

    // InputStream public API
    this.length = -1;
    this.loaded = false;
    this.loading = false;
    this.seekable = false;
    this.buffering = false;
    this.seeking = false;
    this.progressive = progressive;

    Object.defineProperties(this, {
      /**
       * Byte offset of the read head
       */
      offset: {
        get: function get() {
          return this._cache.readOffset;
        }
      },

      /**
       * Is the read head at the end of the file?
       */
      eof: {
        get: function get() {
          return this.length === this._cache.readOffset;
        }
      }
    });

    // StreamFile public API
    this.url = url;
    this.headers = {};

    // Private
    this._cache = new CachePool({
      cacheSize: cacheSize
    });

    this._backend = null;
    this._cachever = 0;
    this._chunkSize = chunkSize;
  }

  /**
   * Open the file, get metadata, and start buffering some data.
   * On success, loaded will become true, headers may be filled out,
   * and length may be available.
   *
   * @returns {Promise}
   */


  _createClass(StreamFile, [{
    key: 'load',
    value: function load() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (_this.loading) {
          throw new Error('cannot load when loading');
        }
        if (_this.loaded) {
          throw new Error('cannot load when loaded');
        }
        _this.loading = true;
        _this._openBackend().then(function (backend) {
          // Save metadata from the first set...
          // Beware this._backend may be null already,
          // if the first segment was very short!
          _this.seekable = backend.seekable;
          _this.headers = backend.headers;
          _this.length = backend.length;
          _this.loaded = true;
          _this.loading = false;
          resolve();
        }).catch(function (err) {
          if (err.name !== 'AbortError') {
            _this.loading = false;
          }
          reject(err);
        });
      });
    }

    /**
     * Create a backend and wait for it to load.
     * The returned 'backend' object may be null if there is no data to read.
     *
     * @returns {Promise}
     */

  }, {
    key: '_openBackend',
    value: function _openBackend() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (_this2._backend) {
          resolve(_this2._backend);
        } else if (_this2.eof) {
          reject(new Error('cannot open at end of file'));
        } else {
          var cache = _this2._cache;
          var max = _this2._chunkSize;

          // Seek forward to the next unread point, up to chunk size
          var readable = cache.bytesReadable(max);
          var readTail = cache.readOffset + readable;
          cache.seekWrite(readTail);

          // Did we already cache the entire file?
          if (_this2.length >= 0 && readTail >= _this2.length) {
            resolve(null);
            return;
          }

          // Do we have space to write within that chunk?
          // Don't go beyond the end of the file, or it will confuse
          // some browsers (Safari with blob URLs).
          var writable = _this2._clampToLength(cache.writeOffset + cache.bytesWritable(max)) - cache.writeOffset;

          if (writable === 0) {
            // Nothing to read/write within the current readahead area.
            resolve(null);
          } else {
            (function () {
              var backend = _this2._backend = new Backend({
                url: _this2.url,
                offset: _this2._cache.writeOffset,
                length: writable,
                cachever: _this2._cachever,
                progressive: _this2.progressive
              });

              var oncomplete = null;

              var checkOpen = function checkOpen() {
                if (backend !== _this2._backend) {
                  oncomplete();
                  reject(new Error('invalid state'));
                } else {
                  backend.on('buffer', function (buffer) {
                    if (backend === _this2._backend) {
                      _this2._cache.write(buffer);
                    }
                  });
                  backend.on('done', function () {
                    if (backend === _this2._backend) {
                      if (_this2.length === -1) {
                        // save length on those final thingies
                        _this2.length = _this2._backend.offset + _this2._backend.bytesRead;
                      }
                      _this2._backend = null;
                    }
                  });
                  resolve(backend);
                }
              };

              var checkError = function checkError(err) {
                if (backend !== _this2._backend) {
                  reject(new Error('invalid state'));
                } else {
                  _this2._backend = null;
                  reject(err);
                }
              };

              oncomplete = function oncomplete() {
                backend.off('open', checkOpen);
                backend.off('error', checkError);
              };
              backend.on('open', checkOpen);
              backend.on('error', checkError);
              backend.on('cachever', function () {
                _this2._cachever++;
              });

              backend.load();
            })();
          }
        }
      });
    }

    /**
     * If we have empty space within the readahead area and there is not already
     * a download backend in place, create one and start it loading in background.
     * @returns {Promise}
     */

  }, {
    key: '_readAhead',
    value: function _readAhead() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3._backend || _this3.eof) {
          // do nothing
          resolve();
        } else {
          _this3._openBackend().then(function () {
            resolve();
          }).catch(function (err) {
            reject(err);
          });
        }
      });
    }

    /**
     * Seek the read position to a new location in the file, asynchronously.
     * After succesful completion, reads will continue at the new offset.
     * May fail due to network problems, invalid input, or bad state.
     * @param {number} offset - target byte offset from beginning of file
     * @returns {Promise} - resolved when ready to read at the new position
     */

  }, {
    key: 'seek',
    value: function seek(offset) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (!_this4.loaded || _this4.buffering || _this4.seeking) {
          throw new Error('invalid state');
        } else if (offset !== (offset | 0) || offset < 0) {
          throw new Error('invalid input');
        } else if (_this4.length >= 0 && offset > _this4.length) {
          throw new Error('seek past end of file');
        } else if (!_this4.seekable) {
          throw new Error('seek on non-seekable stream');
        } else {
          if (_this4._backend) {
            // @todo if a short seek forward, just keep reading?
            _this4.abort();
          }
          _this4._cache.seekRead(offset);
          _this4._cache.seekWrite(offset);

          // Fire off a download if necessary.
          _this4._readAhead().then(resolve).catch(reject);
        }
      });
    }

    /**
     * Read up to the requested number of bytes, or until end of file is reached,
     * and advance the read head.
     *
     * May wait on network activity if data is not yet available.
     *
     * @param {number} nbytes - max number of bytes to read
     * @returns {ArrayBuffer} - between 0 and nbytes of data, inclusive
     */

  }, {
    key: 'read',
    value: function read(nbytes) {
      var _this5 = this;

      return this.buffer(nbytes).then(function (available) {
        return _this5.readSync(available);
      });
    }

    /**
     * Read up to the requested number of bytes, or however much is available
     * in the buffer until the next empty segment, and advance the read head.
     *
     * Returns immediately.
     *
     * @param {number} nbytes - max number of bytes to read
     * @returns {ArrayBuffer} - between 0 and nbytes of data, inclusive
     */

  }, {
    key: 'readSync',
    value: function readSync(nbytes) {
      var available = this.bytesAvailable(nbytes);
      var dest = new Uint8Array(available);
      var actual = this.readBytes(dest);
      if (actual !== available) {
        throw new Error('failed to read expected data');
      }
      return dest.buffer;
    }

    /**
     * Read bytes into destination array until out of buffer or space,
     * and advance the read head.
     *
     * Returns immediately.
     *
     * @param {dest} Uint8Array - destination byte array
     * @returns {number} - count of actual bytes read
     */

  }, {
    key: 'readBytes',
    value: function readBytes(dest) {
      if (!this.loaded || this.buffering || this.seeking) {
        throw new Error('invalid state');
      } else if (!(dest instanceof Uint8Array)) {
        throw new Error('invalid input');
      }
      var nbytes = this._cache.readBytes(dest);

      // Trigger readahead if necessary.
      this._readAhead();

      return nbytes;
    }

    /**
     * Wait until the given number of bytes are available to read, or end of file.
     * @param {number} nbytes - max bytes to wait for
     * @returns {Promise} - resolved with available byte count when ready
     */

  }, {
    key: 'buffer',
    value: function buffer(nbytes) {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        if (!_this6.loaded || _this6.buffering || _this6.seeking) {
          throw new Error('invalid state');
        } else if (nbytes !== (nbytes | 0) || nbytes < 0) {
          throw new Error('invalid input');
        }
        var end = _this6._clampToLength(_this6.offset + nbytes);
        var readable = end - _this6.offset;

        var canceled = false;

        var available = _this6.bytesAvailable(readable);
        if (available >= readable) {
          // Requested data is immediately available.
          resolve(available);
        } else {
          _this6.buffering = true;

          // If we don't already have a backend open, start downloading.
          _this6._openBackend().then(function (backend) {
            if (backend) {
              return backend.bufferToOffset(end).then(function () {
                // We might have to roll over to another download,
                // so loop back around!
                _this6.buffering = false;
                return _this6.buffer(nbytes);
              });
            } else {
              // No more data to read.
              return Promise.resolve(available);
            }
          }).then(function (available) {
            _this6.buffering = false;
            resolve(available);
          }).catch(function (err) {
            if (err.name !== 'AbortError') {
              // was already set synchronously; avoid stomping on old promise
              _this6.buffering = false;
            }
            reject(err);
          });
        }
      });
    }

    /**
     * Number of bytes available to read immediately from the current offset.
     * This is the max number of bytes that can be returned from a read() call.
     * @returns {boolean}
     */

  }, {
    key: 'bytesAvailable',
    value: function bytesAvailable() {
      var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;

      return this._cache.bytesReadable(max);
    }

    /**
     * Abort any currently running downloads and operations.
     */

  }, {
    key: 'abort',
    value: function abort() {
      // Clear state synchronously, so can immediately launch new i/o...
      if (this.loading) {
        this.loading = false;
      }
      if (this.buffering) {
        this.buffering = false;
      }
      if (this.seeking) {
        this.seeking = false;
      }

      // Abort any active backend request...
      if (this._backend) {
        this._backend.abort();
        this._backend = null;
      }
    }

    /**
     * Return an array of byte ranges that are buffered.
     * Each range is a two-element array of start and end.
     * @returns {Array<Array<number>>}
     */

  }, {
    key: 'getBufferedRanges',
    value: function getBufferedRanges() {
      return this._cache.ranges();
    }

    // ------
    // private methods
    // ------

  }, {
    key: '_clampToLength',
    value: function _clampToLength(offset) {
      if (this.length < 0) {
        return offset;
      } else {
        return Math.min(this.length, offset);
      }
    }
  }]);

  return StreamFile;
}();

module.exports = StreamFile;

},{"./backend":5,"./cache":10,"./events":11}]},{},[12])(12)
});